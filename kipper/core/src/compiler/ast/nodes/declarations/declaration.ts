/**
 * The base abstract AST node class for all declarations/declarations, which wrap their corresponding
 * {@link KipperParserRuleContext} rule context classes that were generated by the {@link KipperParser}.
 *
 * These AST nodes can be created with the {@link DeclarationASTNodeFactory} class.
 *
 * Note! Any function, variable or parameter declaration in Kipper will be registered in a {@link Scope}, which will
 * define the visibility of the variable. The only exception is a {@link ParameterDeclaration}, which is bound to a
 * function and its local scope.
 * @since 0.1.0
 */
import type { DeclarationSemantics } from "../../semantic-data";
import type { DeclarationTypeData } from "../../type-data";
import type { TranslatedCodeLine } from "../../../const";
import type { ASTDeclarationKind, ParserDeclarationContext } from "../../ast-types";
import type { TargetASTNodeCodeGenerator, TargetASTNodeSemanticAnalyser } from "../../../target-presets";
import type { ScopeDeclaration } from "../../../analysis";
import { CompilableASTNode, type CompilableNodeParent } from "../../compilable-ast-node";
import { UndefinedDeclarationCtxError } from "../../../../errors";

/**
 * The base abstract AST node class for all declarations/declarations, which wrap their corresponding
 * {@link KipperParserRuleContext} rule context classes that were generated by the {@link KipperParser}.
 *
 * These AST nodes can be created with the {@link DeclarationASTNodeFactory} class.
 *
 * Note! Any function, variable or parameter declaration in Kipper will be registered in a {@link Scope}, which will
 * define the visibility of the variable. The only exception is a {@link ParameterDeclaration}, which is bound to a
 * function and its local scope.
 * @since 0.1.0
 */
export abstract class Declaration<
	Semantics extends DeclarationSemantics = DeclarationSemantics,
	TypeData extends DeclarationTypeData = DeclarationTypeData,
> extends CompilableASTNode<Semantics, TypeData> {
	/**
	 * The private field '_antlrRuleCtx' that actually stores the variable data,
	 * which is returned inside the {@link this.antlrRuleCtx}.
	 * @private
	 */
	protected override readonly _antlrRuleCtx: ParserDeclarationContext;

	/**
	 * The private field '_scopeDeclaration' that actually stores the variable data,
	 * which is returned inside the {@link this.scopeDeclaration}.
	 * @private
	 */
	protected _scopeDeclaration: ScopeDeclaration | undefined;

	/**
	 * Returns the kind of this AST node. This represents the specific type of the {@link antlrRuleCtx} that this AST
	 * node wraps.
	 *
	 * This may be compared using the {@link KipperParser} rule fields, for example {@link KipperParser.RULE_expression}.
	 * @since 0.10.0
	 */
	public abstract readonly kind: ASTDeclarationKind;

	protected constructor(antlrRuleCtx: ParserDeclarationContext, parent: CompilableNodeParent) {
		super(antlrRuleCtx, parent);
		this._antlrRuleCtx = antlrRuleCtx;

		// Manually add the child to the parent
		parent.addNewChild(this);
	}

	/**
	 * The antlr context containing the antlr4 metadata for this expression.
	 */
	public override get antlrRuleCtx(): ParserDeclarationContext {
		return this._antlrRuleCtx;
	}

	/**
	 * The {@link ScopeDeclaration} context instance for this declaration, which is used to register the declaration
	 * in the {@link scope parent scope}.
	 * @since 0.10.0
	 */
	public get scopeDeclaration(): ScopeDeclaration | undefined {
		return this._scopeDeclaration;
	}

	protected set scopeDeclaration(declaration: ScopeDeclaration | undefined) {
		this._scopeDeclaration = declaration;
	}

	/**
	 * Returns the {@link scopeDeclaration scope declaration ctx} of this declaration and throws an error in case
	 * it is undefined.
	 * @throws UndefinedDeclarationCtx If {@link scopeDeclaration} is undefined.
	 * @since 0.10.0
	 */
	public getScopeDeclaration(): ScopeDeclaration {
		if (!this.scopeDeclaration) {
			throw new UndefinedDeclarationCtxError();
		}
		return this.scopeDeclaration;
	}

	/**
	 * Generates the typescript code for this item, and all children (if they exist).
	 * @since 0.8.0
	 */
	public async translateCtxAndChildren(): Promise<Array<TranslatedCodeLine>> {
		return await this.targetCodeGenerator(this);
	}

	public abstract targetSemanticAnalysis: TargetASTNodeSemanticAnalyser<any> | undefined;
	public abstract targetCodeGenerator: TargetASTNodeCodeGenerator<any, Array<TranslatedCodeLine>>;
}
