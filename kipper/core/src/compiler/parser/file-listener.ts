/**
 * Antlr4 listener for walking through a parser tree and processing its content.
 * @since 0.0.3
 */
import type {
	ActualAdditiveExpressionContext,
	ActualAssignmentExpressionContext,
	ActualCastOrConvertExpressionContext,
	ActualConditionalExpressionContext,
	ActualEqualityExpressionContext,
	ActualLogicalAndExpressionContext,
	ActualLogicalOrExpressionContext,
	ActualMultiplicativeExpressionContext,
	ActualRelationalExpressionContext,
	AssignmentOperatorContext,
	BoolPrimaryExpressionContext,
	CompilationUnitContext,
	CompoundStatementContext,
	DeclarationContext,
	ExpressionStatementContext,
	FStringPrimaryExpressionContext,
	FunctionCallExpressionContext,
	GenericTypeSpecifierContext,
	IdentifierPrimaryExpressionContext,
	IdentifierTypeSpecifierContext,
	IncrementOrDecrementPostfixExpressionContext,
	IncrementOrDecrementUnaryExpressionContext,
	IterationStatementContext,
	JumpStatementContext,
	KipperParserListener,
	ArrayLiteralPrimaryExpressionContext,
	NumberPrimaryExpressionContext,
	OperatorModifiedUnaryExpressionContext,
	ParameterDeclarationContext,
	StringPrimaryExpressionContext,
	SwitchLabeledStatementContext,
	TangledPrimaryExpressionContext,
	TypeofTypeSpecifierContext,
	UnaryOperatorContext,
	DoWhileLoopIterationStatementContext,
	ExternalItemContext,
	ForLoopIterationStatementContext,
	IfStatementContext,
	InitializerContext,
	ReturnStatementContext,
	SwitchStatementContext,
	VoidOrNullOrUndefinedPrimaryExpressionContext,
	WhileLoopIterationStatementContext,
	FunctionDeclarationContext,
	AssignmentExpressionContext,
	CastOrConvertExpressionContext,
	ConditionalExpressionContext,
	DeclaratorContext,
	DirectDeclaratorContext,
	ExpressionContext,
	InitDeclaratorContext,
	ParameterListContext,
	PassOnAssignmentExpressionContext,
	PassOnCastOrConvertExpressionContext,
	PassOnConditionalExpressionContext,
	PassOnLogicalOrExpressionContext,
	PassOnPostfixExpressionContext,
	PassOnUnaryExpressionContext,
	StorageTypeSpecifierContext,
	TypeSpecifierContext,
	UnaryExpressionContext,
} from "./antlr";
import type { KipperProgramContext } from "../program-ctx";
import { ParserRuleContext } from "antlr4ts";
import {
	type antlrDefinitionCtxType,
	type antlrExpressionCtxType,
	type antlrStatementCtxType,
	Declaration,
	DefinitionASTNodeFactory,
	Expression,
	ExpressionASTNodeFactory,
	Statement,
	StatementASTNodeFactory,
	RootASTNode,
	CompilableASTNode,
} from "../ast";
import { KipperInternalError } from "../../errors";
import {
	AdditiveExpressionContext,
	EqualityExpressionContext,
	LogicalAndExpressionContext,
	LogicalOrExpressionContext,
	MultiplicativeExpressionContext,
	PassOnAdditiveExpressionContext,
	PassOnEqualityExpressionContext,
	PassOnLogicalAndExpressionContext,
	PassOnMultiplicativeExpressionContext,
	PassOnRelationalExpressionContext,
	PostfixExpressionContext,
	PrimaryExpressionContext,
	RelationalExpressionContext,
	VariableDeclarationContext,
} from "./antlr";

/**
 * The listener for a {@link KipperProgramContext}, which walks through a parse tree generated by Antlr4 and generates
 * an abstract syntax tree based on The parse tree.
 * @since 0.0.3
 */
export class KipperFileListener implements KipperParserListener {
	/**
	 * The private field '_itemBuffer' that actually stores the variable data,
	 * which is returned inside the {@link this.itemBuffer}.
	 * @private
	 */
	private readonly _rootNode: RootASTNode;

	/**
	 * If this is true, the current context is inside an external item and automatically indicates
	 * {@link _isFunctionDefinition} is false.
	 */
	private _isExternalItem: boolean;

	/**
	 * If this is true, the current context is inside a function definition and automatically indicates
	 * {@link _isExternalItem} is false.
	 */
	private _isFunctionDefinition: boolean;

	/**
	 * The current Kipper AST node that is being walked through right now. This is the instance where current metadata
	 * should be added to and read from, as this instance will represent and handle the context rules that were walked
	 * through during this operation.
	 */
	private _currentPrimaryNode: CompilableASTNode<any, any> | undefined;

	/**
	 * The current expression that is being walked through. This is the instance where current metadata
	 * should be added to and read from, as this instance will represent and handle the context rules that were walked
	 * through during this operation.
	 */
	private _currentExpression: Expression<any, any> | undefined;

	constructor(programCtx: KipperProgramContext, rootNode: CompilationUnitContext) {
		this._rootNode = new RootASTNode(programCtx, rootNode);
		this._isExternalItem = false;
		this._isFunctionDefinition = false;
		this._currentPrimaryNode = undefined;
	}

	/**
	 * The root node of the generated abstract syntax tree.
	 * @since 0.8.0
	 */
	public get rootNode(): RootASTNode {
		return this._rootNode;
	}

	/**
	 * Returns which token is being processed at the moment and where meta-data should be assigned to. If
	 * {@link _currentExpression} is defined, then that item will be returned, otherwise {@link _currentPrimaryNode}.
	 * @private
	 */
	private get getCurrentNode(): CompilableASTNode<any, any> | RootASTNode {
		if (this._currentExpression) {
			return this._currentExpression;
		} else if (this._currentPrimaryNode) {
			return this._currentPrimaryNode;
		} else {
			return this.rootNode;
		}
	}

	/**
	 * Handles an incoming expression context. The handling algorithm is:
	 * - If {@link _currentExpression} is undefined, then it will be created and set as a child of the
	 * {@link _currentPrimaryNode}.
	 * - Otherwise, generate a new {@link Expression} instance, which will be added to the {@link _currentExpression} as
	 * a child. Afterwards {@link _currentExpression} will be set to this new instance, as all new context instances
	 * must be assigned to it. When the context is left, then the old {@link _currentExpression} will be restored as
	 * {@link _currentExpression}, and all further context instances will be assigned to it.
	 * @param ctx The context instance of the expression
	 * @private
	 */
	private handleIncomingExpressionCtx(ctx: antlrExpressionCtxType) {
		if (this.getCurrentNode instanceof RootASTNode) {
			throw new KipperInternalError(
				"An expression may not have the root file token as a parent. It must be child to a statement or a" +
					" definition.",
			);
		}

		this._currentExpression = ExpressionASTNodeFactory.create(ctx, this.getCurrentNode);
	}

	/**
	 * Handles an exiting expression context. The handling algorithm is:
	 * - If {@link _currentExpression.parent} is of type {@link Expression}, then set {@link _currentExpression} to
	 * that parent.
	 * - Otherwise set {@link _currentExpression} to {@link undefined} again. If  {@link handleIncomingExpressionCtx} is
	 * called again, the {@link _currentExpression} will be defined again and the whole process starts again.
	 * @private
	 */
	private handleExitingExpressionCtx() {
		if (this._currentExpression?.parent instanceof Expression) {
			this._currentExpression = this._currentExpression.parent;
		} else {
			this._currentExpression = undefined;
		}
	}

	/**
	 * Handles an incoming statement context. The handling algorithm is as following:
	 * - If {@link _currentPrimaryNode} is undefined, then it will be created and set as a child of
	 * {@link _rootNode}
	 * - Otherwise, generate a new {@link Statement} instance, which will be added to the {@link _currentPrimaryNode} as
	 * a child. Afterwards {@link _currentPrimaryNode} will be set to this new instance, as all new context instances
	 * must be assigned to it. When the context is left, then the old {@link _currentPrimaryNode} will be restored as
	 * {@link _currentPrimaryNode}, and all further context instances will be assigned to it.
	 * @private
	 */
	private handleIncomingStatementCtx(ctx: antlrStatementCtxType) {
		this._currentPrimaryNode = StatementASTNodeFactory.create(ctx, this.getCurrentNode);
	}

	/**
	 * Handles an incoming statement context. The handling algorithm is as following:
	 * - If {@link _currentPrimaryNode} is undefined, then it will be created and set as a child of
	 * {@link _rootNode}
	 * - Otherwise, generate a new {@link Declaration} instance, which will be added to the {@link _currentPrimaryNode} as
	 * a child. Afterwards {@link _currentPrimaryNode} will be set to this new instance, as all new context instances
	 * must be assigned to it. When the context is left, then the old {@link _currentPrimaryNode} will be restored as
	 * {@link _currentPrimaryNode}, and all further context instances will be assigned to it.
	 * @private
	 */
	private handleIncomingDefinitionCtx(ctx: antlrDefinitionCtxType) {
		this._currentPrimaryNode = DefinitionASTNodeFactory.create(ctx, this.getCurrentNode);
	}

	/**
	 * Handles an exiting statement or definition context. The handling algorithm is as following:
	 * - If {@link _currentPrimaryNode.parent} is of type {@link _currentPrimaryNode} or {@link Statement}, then set
	 * {@link _currentPrimaryNode} to that parent.
	 * - Otherwise set {@link _currentPrimaryNode} to {@link undefined} again. If
	 * {@link handleExitingStatementOrDefinitionCtx} is called again, the {@link _currentPrimaryNode} will be defined
	 * again and the whole process starts again.
	 * @private
	 */
	private handleExitingStatementOrDefinitionCtx() {
		if (
			this._currentPrimaryNode?.parent instanceof Declaration ||
			this._currentPrimaryNode?.parent instanceof Statement
		) {
			this._currentPrimaryNode = this._currentPrimaryNode.parent;
		} else {
			this._currentPrimaryNode = undefined;
		}
	}

	/**
	 * Function that is called every time an item is entered.
	 * @param ctx The context of the rule
	 */
	public enterEveryRule?(/*@NotNull*/ ctx: ParserRuleContext): void;

	/**
	 * Function that is called every time an item is exited.
	 * @param ctx The context of the rule.
	 */
	public exitEveryRule?(/*@NotNull*/ ctx: ParserRuleContext): void;

	// -------------------------------------------------------------------------------------------------------------------
	//  Root Item section
	// -------------------------------------------------------------------------------------------------------------------

	/**
	 * Enter a parse tree produced by the `externalItem`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterExternalItem(ctx: ExternalItemContext): void {
		this._isExternalItem = true;
	}

	/**
	 * Exit a parse tree produced by the `externalItem`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitExternalItem(ctx: ExternalItemContext): void {
		this._isExternalItem = false;
	}

	// -------------------------------------------------------------------------------------------------------------------
	//  Expression section
	// -------------------------------------------------------------------------------------------------------------------
	//
	// NOTE:
	// We are ignoring primary expressions, and only going to handle the rules 'identifierPrimaryExpression'
	// 'constantPrimaryExpression', 'stringPrimaryExpression', 'fStringPrimaryExpression' and
	// 'tangledPrimaryExpression', which implement a more precise 'primaryExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.primaryExpression`.
	 *
	 * This is the lowest expression / This has the highest importance of all!
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterPrimaryExpression?(ctx: PrimaryExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitPrimaryExpression?(ctx: PrimaryExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `identifierPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIdentifierPrimaryExpression(ctx: IdentifierPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `identifierPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIdentifierPrimaryExpression(ctx: IdentifierPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `stringPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterStringPrimaryExpression(ctx: StringPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `stringPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitStringPrimaryExpression(ctx: StringPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `fStringPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterFStringPrimaryExpression(ctx: FStringPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `fStringPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitFStringPrimaryExpression(ctx: FStringPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `tangledPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterTangledPrimaryExpression(ctx: TangledPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `tangledPrimaryExpression`
	 * Labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitTangledPrimaryExpression(ctx: TangledPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `numberPrimaryExpression`
	 * labeled alternative in `KipperParser.PrimaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterNumberPrimaryExpression(ctx: NumberPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `numberPrimaryExpression`
	 * labeled alternative in `KipperParser.PrimaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitNumberPrimaryExpression(ctx: NumberPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `listConstantPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterArrayLiteralPrimaryExpression(ctx: ArrayLiteralPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `listConstantPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitArrayLiteralPrimaryExpression(ctx: ArrayLiteralPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `boolPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterBoolPrimaryExpression(ctx: BoolPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `boolPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitBoolPrimaryExpression(ctx: BoolPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `VoidOrNullOrUndefinedPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterVoidOrNullOrUndefinedPrimaryExpression(ctx: VoidOrNullOrUndefinedPrimaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `VoidOrNullOrUndefinedPrimaryExpression`
	 * labeled alternative in `KipperParser.primaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitVoidOrNullOrUndefinedPrimaryExpression(ctx: VoidOrNullOrUndefinedPrimaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring postfix expressions, and only going to handle the rules 'referenceExpression' and
	// 'functionCallExpression', which implement a more precise 'postfixExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterPostfixExpression?(ctx: PostfixExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitPostfixExpression?(ctx: PostfixExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnPostfixExpression?(ctx: PassOnPostfixExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnPostfixExpression?(ctx: PassOnPostfixExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `incrementOrDecrementPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIncrementOrDecrementPostfixExpression(ctx: IncrementOrDecrementPostfixExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `incrementOrDecrementPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIncrementOrDecrementPostfixExpression(ctx: IncrementOrDecrementPostfixExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `functionCallPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterFunctionCallExpression(ctx: FunctionCallExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `functionCallPostfixExpression`
	 * Labeled alternative in `KipperParser.postfixExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitFunctionCallExpression(ctx: FunctionCallExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring the 'unary' rule, and only going to handle the rules 'passOnUnaryExpression',
	// 'incrementOrDecrementUnaryExpression' and 'operatorModifiedUnaryExpression', which implement a more precise
	// 'unaryExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterUnaryExpression?(ctx: UnaryExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitUnaryExpression?(ctx: UnaryExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnUnaryExpression?(ctx: PassOnUnaryExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnUnaryExpression?(ctx: PassOnUnaryExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `incrementOrDecrementUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIncrementOrDecrementUnaryExpression(ctx: IncrementOrDecrementUnaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `incrementOrDecrementUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIncrementOrDecrementUnaryExpression(ctx: IncrementOrDecrementUnaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `operatorModifiedUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterOperatorModifiedUnaryExpression(ctx: OperatorModifiedUnaryExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `operatorModifiedUnaryExpression`
	 * Labeled alternative in `KipperParser.unaryExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitOperatorModifiedUnaryExpression(ctx: OperatorModifiedUnaryExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.unaryOperator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterUnaryOperator(ctx: UnaryOperatorContext): void {}

	/**
	 * Exit a parse tree produced by `KipperParser.unaryOperator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitUnaryOperator(ctx: UnaryOperatorContext): void {}

	// NOTE:
	// We are ignoring the 'castOrConvertExpression' rule, and only going to handle the rules
	// 'passOnCastOrConvertExpression', and 'actualCastOrConvertExpression', which implement a more precise
	// 'castOrConvertExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.castOrConvertExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterCastOrConvertExpression?(ctx: CastOrConvertExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.castOrConvertExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitCastOrConvertExpression?(ctx: CastOrConvertExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnCastOrConvertExpression`
	 * Labeled alternative in `KipperParser.castOrConvertExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnCastOrConvertExpression?(ctx: PassOnCastOrConvertExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnCastOrConvertExpression`
	 * Labeled alternative in `KipperParser.castOrConvertExpression`. // Pass-on -> skip
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnCastOrConvertExpression?(ctx: PassOnCastOrConvertExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualCastOrConvertExpression`
	 * Labeled alternative in `KipperParser.castOrConvertExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualCastOrConvertExpression(ctx: ActualCastOrConvertExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualCastOrConvertExpression`
	 * Labeled alternative in `KipperParser.castOrConvertExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualCastOrConvertExpression(ctx: ActualCastOrConvertExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring multiplicative expressions, and only going to handle the rules 'passOnMultiplicativeExpression',
	// and 'actualMultiplicativeExpression', which implement a more precise 'multiplicativeExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterMultiplicativeExpression?(ctx: MultiplicativeExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitMultiplicativeExpression?(ctx: MultiplicativeExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnMultiplicativeExpression`
	 * Labeled alternative in `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnMultiplicativeExpression?(ctx: PassOnMultiplicativeExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnMultiplicativeExpression`
	 * Labeled alternative in `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnMultiplicativeExpression?(ctx: PassOnMultiplicativeExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualMultiplicativeExpression`
	 * Labeled alternative in `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualMultiplicativeExpression(ctx: ActualMultiplicativeExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualMultiplicativeExpression`
	 * Labeled alternative in `KipperParser.multiplicativeExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualMultiplicativeExpression(ctx: ActualMultiplicativeExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring additive expressions, and only going to handle the rules 'passOnAdditiveExpression',
	// and 'actualAdditiveExpression', which implement a more precise 'additiveExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time
	// an expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterAdditiveExpression?(ctx: AdditiveExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitAdditiveExpression?(ctx: AdditiveExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnAdditiveExpression`
	 * Labeled alternative in `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnAdditiveExpression?(ctx: PassOnAdditiveExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnAdditiveExpression`
	 * Labeled alternative in `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnAdditiveExpression?(ctx: PassOnAdditiveExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualAdditiveExpression`
	 * Labeled alternative in `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualAdditiveExpression(ctx: ActualAdditiveExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualAdditiveExpression`
	 * Labeled alternative in `KipperParser.additiveExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualAdditiveExpression(ctx: ActualAdditiveExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring relational expressions, and only going to handle the rules 'passOnRelationalExpression',
	// and 'actualRelationalExpression', which implement a more precise 'relationalExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterRelationalExpression?(ctx: RelationalExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitRelationalExpression?(ctx: RelationalExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnRelationalExpression`
	 * Labeled alternative in `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnRelationalExpression?(ctx: PassOnRelationalExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnRelationalExpression`
	 * Labeled alternative in `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnRelationalExpression?(ctx: PassOnRelationalExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualRelationalExpression`
	 * Labeled alternative in `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualRelationalExpression(ctx: ActualRelationalExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualRelationalExpression`
	 * Labeled alternative in `KipperParser.relationalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualRelationalExpression(ctx: ActualRelationalExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring equality expressions, and only going to handle the rules 'passOnEqualityExpression',
	// and 'actualEqualityExpression', which implement a more precise 'equalityExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterEqualityExpression?(ctx: EqualityExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitEqualityExpression?(ctx: EqualityExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnEqualityExpression`
	 * Labeled alternative in `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnEqualityExpression?(ctx: PassOnEqualityExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnEqualityExpression`
	 * Labeled alternative in `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnEqualityExpression?(ctx: PassOnEqualityExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualEqualityExpression`
	 * Labeled alternative in `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualEqualityExpression(ctx: ActualEqualityExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualEqualityExpression`
	 * Labeled alternative in `KipperParser.equalityExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualEqualityExpression(ctx: ActualEqualityExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring logical and expressions, and only going to handle the rules 'passOnLogicalAndExpression',
	// and 'actualLogicalAndExpression', which implement a more precise 'logicalAndExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterLogicalAndExpression?(ctx: LogicalAndExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitLogicalAndExpression?(ctx: LogicalAndExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnLogicalAndExpression`
	 * Labeled alternative in `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnLogicalAndExpression?(ctx: PassOnLogicalAndExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnLogicalAndExpression`
	 * Labeled alternative in `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnLogicalAndExpression?(ctx: PassOnLogicalAndExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualLogicalAndExpression`
	 * Labeled alternative in `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualLogicalAndExpression(ctx: ActualLogicalAndExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualLogicalAndExpression`
	 * Labeled alternative in `KipperParser.logicalAndExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualLogicalAndExpression(ctx: ActualLogicalAndExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring logical or expressions, and only going to handle the rules 'passOnLogicalOrExpression',
	// and 'actualLogicalOrExpression', which implement a more precise 'logicalOrExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterLogicalOrExpression?(ctx: LogicalOrExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitLogicalOrExpression?(ctx: LogicalOrExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnLogicalOrExpression`
	 * Labeled alternative in `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnLogicalOrExpression?(ctx: PassOnLogicalOrExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnLogicalOrExpression`
	 * Labeled alternative in `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnLogicalOrExpression?(ctx: PassOnLogicalOrExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualLogicalOrExpression`
	 * Labeled alternative in `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualLogicalOrExpression(ctx: ActualLogicalOrExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualLogicalOrExpression`
	 * Labeled alternative in `KipperParser.logicalOrExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualLogicalOrExpression(ctx: ActualLogicalOrExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring conditional expressions, and only going to handle the rules 'passOnConditionalExpression',
	// and 'actualConditionalExpression', which implement a more precise 'conditionalExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterConditionalExpression?(ctx: ConditionalExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitConditionalExpression?(ctx: ConditionalExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnConditionalExpression`
	 * Labeled alternative in `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnConditionalExpression?(ctx: PassOnConditionalExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnConditionalExpression`
	 * Labeled alternative in `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnConditionalExpression?(ctx: PassOnConditionalExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualConditionalExpression`
	 * Labeled alternative in `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualConditionalExpression(ctx: ActualConditionalExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualConditionalExpression`
	 * Labeled alternative in `KipperParser.conditionalExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualConditionalExpression(ctx: ActualConditionalExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	// NOTE:
	// We are ignoring assignment expressions, and only going to handle the rules 'passOnAssignmentExpression',
	// and 'actualAssignmentExpression', which implement a more precise 'assignmentExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	/**
	 * Enter a parse tree produced by `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public enterAssignmentExpression?(ctx: AssignmentExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	public exitAssignmentExpression?(ctx: AssignmentExpressionContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by the `passOnAssignmentExpression`
	 * Labeled alternative in `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterPassOnAssignmentExpression?(ctx: PassOnAssignmentExpressionContext): void; // Pass-on -> skip

	/**
	 * Exit a parse tree produced by the `passOnAssignmentExpression`
	 * Labeled alternative in `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitPassOnAssignmentExpression?(ctx: PassOnAssignmentExpressionContext): void; // Pass-on -> skip

	/**
	 * Enter a parse tree produced by the `actualAssignmentExpression`
	 * Labeled alternative in `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterActualAssignmentExpression(ctx: ActualAssignmentExpressionContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `actualAssignmentExpression`
	 * Labeled alternative in `KipperParser.assignmentExpression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitActualAssignmentExpression(ctx: ActualAssignmentExpressionContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.assignmentOperator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterAssignmentOperator?(ctx: AssignmentOperatorContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.assignmentOperator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitAssignmentOperator?(ctx: AssignmentOperatorContext): void; // Unspecific parent -> skip

	// NOTE:
	// We are ignoring standard expressions, as the children will handle everything.

	/**
	 * Enter a parse tree produced by `KipperParser.expression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	enterExpression?(ctx: ExpressionContext): void {}

	/**
	 * Exit a parse tree produced by `KipperParser.expression`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext})
	 */
	exitExpression?(ctx: ExpressionContext): void {}

	// -------------------------------------------------------------------------------------------------------------------
	//  Statement section
	// -------------------------------------------------------------------------------------------------------------------
	//
	// NOTE:
	// We are ignoring the 'statement' rule, and only going to handle the rules 'expressionStatement', 'labeledStatement'
	// 'selectionStatement', 'iterationStatement' (do-while, while and loop), 'jumpStatement' and 'compoundStatement',
	// which implement a more precise 'statement' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.

	// /**
	//  * Enter a parse tree produced by `KipperParser.statement`.
	//  * @param ctx The parse tree (instance of {@link ParserRuleContext})
	//  */
	// enterStatement(ctx: StatementContext): void {}
	//
	// /**
	//  * Exit a parse tree produced by `KipperParser.statement`.
	//  * @param ctx The parse tree (instance of {@link ParserRuleContext})
	//  */
	// exitStatement(ctx: StatementContext): void {}

	/**
	 * Enter a parse tree produced by `KipperParser.expressionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterExpressionStatement(ctx: ExpressionStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.expressionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitExpressionStatement(ctx: ExpressionStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.compoundStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterCompoundStatement(ctx: CompoundStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.compoundStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitCompoundStatement(ctx: CompoundStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	// NOTE:
	// We are ignoring selection statements, and only going to handle the rules 'ifStatement' and 'switchStatement',
	// which implement a more precise 'assignmentExpression' rule.
	//
	// This is to simplify the walking process, without having to check if the expression is actually used every time an
	// expression is called.
	//
	// /**
	//  * Enter a parse tree produced by `KipperParser.selectionStatement`.
	//  * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	//  */
	// enterSelectionStatement(ctx: SelectionStatementContext): void { }
	//
	// /**
	//  * Exit a parse tree produced by `KipperParser.selectionStatement`.
	//  * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	//  */
	// exitSelectionStatement(ctx: SelectionStatementContext): void { }

	/**
	 * Enter a parse tree produced by the `ifStatement`
	 * labeled alternative in `KipperParser.selectionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIfStatement(ctx: IfStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `ifStatement`
	 * labeled alternative in `KipperParser.selectionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIfStatement(ctx: IfStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by the `switchStatement`
	 * labeled alternative in `KipperParser.selectionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterSwitchStatement(ctx: SwitchStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `switchStatement`
	 * labeled alternative in `KipperParser.selectionStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitSwitchStatement(ctx: SwitchStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.labeledStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterSwitchLabeledStatement(ctx: SwitchLabeledStatementContext): void {
		// TODO! Implement switch statements
	}

	/**
	 * Exit a parse tree produced by `KipperParser.labeledStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitSwitchLabeledStatement(ctx: SwitchLabeledStatementContext): void {
		// TODO! Implement switch statements
	}

	/**
	 * Enter a parse tree produced by `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIterationStatement(ctx: IterationStatementContext): void {}

	/**
	 * Exit a parse tree produced by `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIterationStatement(ctx: IterationStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.jumpStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterJumpStatement(ctx: JumpStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.jumpStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitJumpStatement(ctx: JumpStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by the `ForLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterForLoopIterationStatement(ctx: ForLoopIterationStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `ForLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitForLoopIterationStatement(ctx: ForLoopIterationStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by the `WhileLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterWhileLoopIterationStatement(ctx: WhileLoopIterationStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `WhileLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitWhileLoopIterationStatement(ctx: WhileLoopIterationStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by the `DoWhileLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterDoWhileLoopIterationStatement(ctx: DoWhileLoopIterationStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `DoWhileLoopIterationStatement`
	 * labeled alternative in `KipperParser.iterationStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitDoWhileLoopIterationStatement(ctx: DoWhileLoopIterationStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.returnStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterReturnStatement(ctx: ReturnStatementContext): void {
		this.handleIncomingStatementCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.returnStatement`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitReturnStatement(ctx: ReturnStatementContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	// -------------------------------------------------------------------------------------------------------------------
	//  Declaration section
	// -------------------------------------------------------------------------------------------------------------------

	/**
	 * Enter a parse tree produced by `KipperParser.declaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterDeclaration?(ctx: DeclarationContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.declaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitDeclaration?(ctx: DeclarationContext): void;

	/**
	 * Enter a parse tree produced by `KipperParser.variableDeclaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterVariableDeclaration(ctx: VariableDeclarationContext): void {
		this.handleIncomingDefinitionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.variableDeclaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitVariableDeclaration(ctx: VariableDeclarationContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.functionDefinition`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterFunctionDeclaration(ctx: FunctionDeclarationContext): void {
		this.handleIncomingDefinitionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.functionDefinition`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitFunctionDeclaration(ctx: FunctionDeclarationContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.parameterDeclaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterParameterDeclaration(ctx: ParameterDeclarationContext): void {
		this.handleIncomingDefinitionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by `KipperParser.parameterDeclaration`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitParameterDeclaration(ctx: ParameterDeclarationContext): void {
		this.handleExitingStatementOrDefinitionCtx();
	}

	// -- Child Rules Section --

	/**
	 * Enter a parse tree produced by `KipperParser.storageTypeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterStorageTypeSpecifier?(ctx: StorageTypeSpecifierContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.storageTypeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitStorageTypeSpecifier?(ctx: StorageTypeSpecifierContext): void;

	/**
	 * Enter a parse tree produced by `KipperParser.initDeclarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterInitDeclarator?(ctx: InitDeclaratorContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.initDeclarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitInitDeclarator?(ctx: InitDeclaratorContext): void;

	/**
	 * Enter a parse tree produced by the `identifierTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterIdentifierTypeSpecifier(ctx: IdentifierTypeSpecifierContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `identifierTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitIdentifierTypeSpecifier(ctx: IdentifierTypeSpecifierContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `genericTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterGenericTypeSpecifier(ctx: GenericTypeSpecifierContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `genericTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitGenericTypeSpecifier(ctx: GenericTypeSpecifierContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by the `typeofTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterTypeofTypeSpecifier(ctx: TypeofTypeSpecifierContext): void {
		this.handleIncomingExpressionCtx(ctx);
	}

	/**
	 * Exit a parse tree produced by the `typeofTypeSpecifier`
	 * Labeled alternative in `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitTypeofTypeSpecifier(ctx: TypeofTypeSpecifierContext): void {
		this.handleExitingExpressionCtx();
	}

	/**
	 * Enter a parse tree produced by `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterTypeSpecifier?(ctx: TypeSpecifierContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.typeSpecifier`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitTypeSpecifier?(ctx: TypeSpecifierContext): void;

	/**
	 * Enter a parse tree produced by `KipperParser.declarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterDeclarator?(ctx: DeclaratorContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.declarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitDeclarator?(ctx: DeclaratorContext): void;

	/**
	 * Enter a parse tree produced by `KipperParser.directDeclarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterDirectDeclarator?(ctx: DirectDeclaratorContext): void;

	/**
	 * Exit a parse tree produced by `KipperParser.directDeclarator`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitDirectDeclarator?(ctx: DirectDeclaratorContext): void;

	/**
	 * Enter a parse tree produced by `KipperParser.parameterList`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterParameterList?(ctx: ParameterListContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.parameterList`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitParameterList?(ctx: ParameterListContext): void; // Unspecific parent -> skip

	/**
	 * Enter a parse tree produced by `KipperParser.initializer`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public enterInitializer?(ctx: InitializerContext): void; // Unspecific parent -> skip

	/**
	 * Exit a parse tree produced by `KipperParser.initializer`.
	 * @param ctx The parse tree (instance of {@link ParserRuleContext}).
	 */
	public exitInitializer?(ctx: InitializerContext): void; // Unspecific parent -> skip
}
